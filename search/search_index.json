{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"P\u00e1gina de Gerardo","text":"<p>Bienvenido \ud83d\udc4b Esta es una p\u00e1gina para documentar mi progreso en la carrera</p> <p>Con\u00f3ceme</p>"},{"location":"aboutme/","title":"CON\u00d3CEME","text":"<p>Soy Gerardo Esquivel de Luna, tengo 18 a\u00f1os y estudio Ingenier\u00eda Mecatr\u00f3nica en la IBERO Puebla. Hice esta p\u00e1gina para ir guardando lo que voy aprendiendo en la carrera, mis proyectos y todo el proceso de mi aprendizaje.</p> <p>Fuera de clases me gusta mucho el ciclismo de monta\u00f1a, el alpinismo y en general estar en contacto con la naturaleza. Tambi\u00e9n disfruto salir con mis amigos y conocer lugares nuevos, creo que eso me ayuda a despejarme y a ver las cosas de otra manera.</p> <p>Me considero alguien curioso, al que le gusta aprender y vivir experiencias distintas. Con esta secci\u00f3n quiero compartir un poco de mi lado profesional, pero tambi\u00e9n algo personal, para que quien la lea me conozca mejor y vea lo que voy construyendo en el camino.</p> <p>Contacto: 204655@iberopuebla.mx (institucional)</p>"},{"location":"camara/","title":"Visi\u00f3n por Computadora: Manipulaci\u00f3n de Video y Tracking de Objetos (Python/OpenCV)","text":"<p>Esta secci\u00f3n documenta diversas pr\u00e1cticas de Visi\u00f3n por Computadora realizadas con Python y la librer\u00eda OpenCV (cv2). Los ejercicios demuestran la capacidad de adquirir streams de video en tiempo real, aplicar filtros de procesamiento de im\u00e1genes, superponer gr\u00e1ficos y, finalmente, implementar un sistema avanzado de seguimiento de objetos por color con capacidad de control externo mediante Bluetooth.</p>"},{"location":"camara/#entornos","title":"Entornos","text":""},{"location":"camara/#1-captura-basica-y-visualizacion","title":"1. Captura b\u00e1sica y visualizaci\u00f3n","text":"<p>Establece la conexi\u00f3n con la c\u00e1mara (cv2.VideoCapture(0)) y muestra el stream hasta que se presiona la tecla 'q'. </p> <pre><code>import cv2 \n\nvideo = cv2.VideoCapture(0) \n\nwhile True: \n   ret, frame = video.read() \n   if not ret: \n       break \n\n   cv2.imshow(\"Video\", frame)  \n\n   # Salida del bucle \n   if cv2.waitKey(1) &amp; 0xFF == ord('q'):  \n       break \n\nvideo.release()  \ncv2.destroyAllWindows() \n</code></pre>"},{"location":"camara/#11-conversion-a-bn","title":"1.1 Conversion a B/N","text":"<p>Aplica un filtro de color para transformar el video capturado a escala de grises, reduciendo la complejidad de la imagen a una sola dimensi\u00f3n de intensidad. Este es un paso fundamental en muchos algoritmos de visi\u00f3n por computadora para la detecci\u00f3n de bordes y el procesamiento eficiente. </p> <p></p> <pre><code>import cv2 \n\nvideo = cv2.VideoCapture(0) \nwhile True: \n   ret, frame = video.read() \n   if not ret: \n       break \n\n   dibujo = frame.copy()  \n\n   # Convertir el fotograma a escala de grises \n   dibujo = cv2.cvtColor(dibujo, cv2.COLOR_BGR2GRAY)  \n\n   cv2.imshow(\"Video\", frame)  \n   cv2.imshow(\"VIDEO_GRIS\", dibujo) \n\n   if cv2.waitKey(1) &amp; 0xFF == ord('q'): \n       break \n\nvideo.release() \ncv2.destroyAllWindows() \n</code></pre>"},{"location":"camara/#2-manipulacion-de-color","title":"2. Manipulaci\u00f3n de color","text":""},{"location":"camara/#21-tonos-azules-y-rgb-bgr","title":"2.1 Tonos azules y RGB -&gt; BGR","text":"<p>Al convertir de BGR (formato nativo de OpenCV) a RGB (formato est\u00e1ndar de visualizaci\u00f3n), el orden de los canales se invierte. Esta reordenaci\u00f3n produce un predominio de tonos azules y cianes en la visualizaci\u00f3n, ya que los valores asignados al canal Azul se mueven al canal Rojo (\u00edndice 2) y viceversa. </p> <p></p> <pre><code>import cv2 \n\nvideo = cv2.VideoCapture(0) \nwhile True: \n   ret, frame = video.read() \n   if not ret: \n       break \n\n   dibujo = frame.copy()  \n\n   # Conversi\u00f3n simple BGR a RGB (Reordenamiento de canales) \n   dibujo = cv2.cvtColor(dibujo, cv2.COLOR_BGR2RGB)  \n\n   cv2.imshow(\"ORIGINAL\", frame) \n   cv2.imshow(\"FILTRO AZUL\", dibujo) \n\n   if cv2.waitKey(1) &amp; 0xFF == ord('q'): \n       break \n\nvideo.release() \ncv2.destroyAllWindows() \n</code></pre>"},{"location":"camara/#22-filtro-amarillo","title":"2.2 Filtro Amarillo","text":"<p>Para generar una fuerte predominancia de tonos amarillos y rojos (que combinados tienden al amarillo), se anula completamente el canal Azul. En la matriz de imagen BGR utilizada por OpenCV, el canal Azul se encuentra en el \u00edndice 0. </p> <pre><code>import cv2 \nimport numpy as np \n\nvideo = cv2.VideoCapture(0) \nwhile True: \n   ret, frame = video.read() \n   if not ret: \n       break \n\n   dibujo = frame.copy()  \n\n   # Anular el canal azul: [:, :, 0] = 0 \n   # Esto deja activos solo los canales Verde (1) y Rojo (2), resultando en tonos amarillos. \n   dibujo[:, :, 0] = 0  \n\n   cv2.imshow(\"ORIGINAL\", frame) \n   cv2.imshow(\"FILTRO AMARILLO\", dibujo) \n\n   if cv2.waitKey(1) &amp; 0xFF == ord('q'): \n       break \n\nvideo.release() \ncv2.destroyAllWindows() \n</code></pre>"},{"location":"camara/#23-tonos-rosados","title":"2.3 Tonos Rosados","text":"<p>Para obtener una dominante de tonos rosados o magenta, se utiliza la combinaci\u00f3n de los canales Rojo y Azul mientras se anula completamente el canal Verde. En la matriz BGR de OpenCV, el canal Verde se encuentra en el \u00edndice 1. </p> <p></p> <pre><code>import cv2 \nimport numpy as np \n\nvideo = cv2.VideoCapture(0) \nwhile True: \n   ret, frame = video.read() \n   if not ret: \n       break \n\n   dibujo = frame.copy()  \n\n   # Anular el canal verde: [:, :, 1] = 0 \n   # Esto deja activos solo los canales Azul (0) y Rojo (2), resultando en tonos magenta/rosados. \n   dibujo[:, :, 1] = 0  \n\n   cv2.imshow(\"ORIGINAL\", frame) \n   cv2.imshow(\"FILTRO ROSA\", dibujo) \n\n   if cv2.waitKey(1) &amp; 0xFF == ord('q'): \n       break \n\nvideo.release() \ncv2.destroyAllWindows() \n</code></pre>"},{"location":"camara/#superponer-figuras","title":"Superponer figuras","text":"<p>Esta secci\u00f3n demuestra la capacidad de dibujar figuras geom\u00e9tricas (l\u00edneas, rect\u00e1ngulos, c\u00edrculos) y texto sobre los fotogramas del video en tiempo real. Esta t\u00e9cnica es esencial para el tracking, ya que permite visualizar el centro de los objetos, las \u00e1reas de inter\u00e9s (ROI) o los cuadros delimitadores. </p>"},{"location":"camara/#dibujo-de-linea-y-rectangulo","title":"Dibujo de l\u00ednea y rect\u00e1ngulo","text":"<p>Este script dibuja una l\u00ednea diagonal de esquina a esquina y un rect\u00e1ngulo delimitador que enmarca el video. </p> <p></p> <pre><code>import cv2 \n\nvideo = cv2.VideoCapture(0) \nwhile True: \n   ret, frame = video.read() \n   if not ret: \n       break \n\n   dibujo = frame.copy() \n\n   # L\u00ednea diagonal: Dibuja una l\u00ednea roja desde la esquina superior izquierda (0,0) a la inferior derecha (640, 480). \n   cv2.line(dibujo, (0, 0), (640, 480), (0, 0, 225), thickness=3, lineType=cv2.LINE_AA)  \n\n   # Rect\u00e1ngulo de marco: Dibuja un rect\u00e1ngulo azul alrededor del borde de la imagen. \n   cv2.rectangle(dibujo, (0, 0), (640, 480), (255, 0, 0), thickness=10, lineType=cv2.LINE_AA)  \n\n   cv2.imshow(\"Video\", frame) \n   cv2.imshow(\"VIDEO02\", dibujo) \n\n   if cv2.waitKey(1) &amp; 0xFF == ord('q'): \n       break \n\nvideo.release() \ncv2.destroyAllWindows() \n</code></pre>"},{"location":"camara/#32-linea-rectangulo-circulo-y-animacion","title":"3.2 L\u00ednea, Rect\u00e1ngulo, C\u00edrculo y Animaci\u00f3n","text":"<p>Este ejercicio combina varias figuras geom\u00e9tricas y introduce el concepto de animaci\u00f3n usando variables din\u00e1micas (cx, cy). La actualizaci\u00f3n constante de estas variables simula el movimiento del c\u00edrculo a trav\u00e9s del frame, lo cual representa un concepto clave para visualizar el centro de un objeto en movimiento en aplicaciones de tracking. </p> <p></p> <pre><code>import cv2 \n\nvideo = cv2.VideoCapture(0) \ncx = 0  \ncy = 0  \n\nwhile True: \n   ret, frame = video.read() \n   if not ret: \n       break \n\n   dibujo = frame.copy() \n\n   # Figuras est\u00e1ticas \n   cv2.line(dibujo, (0, 0), (640, 480), (0, 0, 225), thickness=3, lineType=cv2.LINE_AA) \n   cv2.rectangle(dibujo, (0, 0), (640, 480), (255, 0, 0), thickness=10, lineType=cv2.LINE_AA) \n\n   # C\u00edrculo animado (centro en cx, cy) \n   cv2.circle(dibujo, (cx, cy), 100, (255, 0, 0), thickness=10, lineType=cv2.LINE_AA) \n\n   # Texto Fijo \n   cv2.putText(dibujo, \"TEXTO FIJO\", (320, 240), cv2.FONT_HERSHEY_SIMPLEX, 2, (255, 0, 0), thickness=2, lineType=cv2.LINE_AA) \n\n   # Actualizaci\u00f3n de posici\u00f3n para animaci\u00f3n \n   # El operador m\u00f3dulo (%) asegura que la posici\u00f3n se reinicie al llegar al borde (640x480). \n   cx = (cx + 1) % 640  \n   cy = (cy + 1) % 480  \n\n   cv2.imshow(\"Video\", frame) \n   cv2.imshow(\"VIDEO02\", dibujo) \n\n   if cv2.waitKey(1) &amp; 0xFF == ord('q'): \n       break \n\nvideo.release() \ncv2.destroyAllWindows() \n</code></pre>"},{"location":"camara/#33-division-de-la-camara-por-secciones-de-color","title":"3.3 Division de la camara por secciones de color","text":"<p>Este ejercicio demuestra el concepto de Regi\u00f3n de Inter\u00e9s (ROI) a trav\u00e9s de la indexaci\u00f3n de matrices de NumPy. Se aplica un filtro de color diferente a cada cuadrante del frame al anular selectivamente un canal de color en una porci\u00f3n espec\u00edfica de la matriz de la imagen. </p> <p></p> <pre><code>import cv2 \nimport numpy as np \n\nvideo = cv2.VideoCapture(0) \nwhile True: \n   ret, frame = video.read() \n   if not ret: \n       break \n\n   dibujo = frame.copy()  \n\n   # Cuadrante 1 (Superior Izquierdo): Anular Canal Verde \n   # Esto resulta en tonos magenta/rosados (Rojo + Azul). \n   # Coordenadas: [Filas 0:240 (Y), Columnas 0:320 (X), Canal Verde (1)] = 0 \n   dibujo[0:240, 0:320, 1] = 0  \n\n   # Cuadrante 2 (Inferior Derecho): Anular Canal Azul \n   # Esto resulta en tonos amarillos (Rojo + Verde). \n   # Coordenadas: [Filas 240:480 (Y), Columnas 320:640 (X), Canal Azul (0)] = 0 \n   dibujo[240:480, 320:640, 0] = 0 \n\n   cv2.imshow(\"Video\", frame)  \n   cv2.imshow(\"VIDEO02\", dibujo) \n\n   if cv2.waitKey(1) &amp; 0xFF == ord('q'): \n       break \n\nvideo.release() \ncv2.destroyAllWindows() \n</code></pre>"},{"location":"camara/#seguimiento-de-objeto-y-control-remoto","title":"Seguimiento de objeto y control remoto","text":"<p>Estos c\u00f3digos aplican la segmentaci\u00f3n por color HSV y el c\u00e1lculo de contornos para localizar el objeto m\u00e1s grande en el frame y calcular su desviaci\u00f3n respecto al centro. Esto simula la l\u00f3gica de un sistema de seguimiento que podr\u00eda ser utilizado para controlar un sistema rob\u00f3tico. </p>"},{"location":"camara/#deteccion-y-tracking-por-color","title":"Deteccion y tracking por color","text":"<p>Este script localiza un objeto de color azul espec\u00edfico, calcula su posici\u00f3n (x, y) y la compara con el centro del frame para determinar el error direccional (ErrorX, ErrorY), imprimi\u00e9ndolo en la consola.  </p> <pre><code>import cv2 \nimport numpy as np \nimport time \n\nvideo = cv2.VideoCapture(0) \n# Rango de color azul en HSV \nbajo = np.array([90, 50, 20], dtype=np.uint8) \nalto = np.array([145, 255, 255], dtype=np.uint8) \n\nwhile True: \n   ret, frame = video.read() \n   if not ret: \n       break \n\n   dibujo = frame.copy() \n   hsv = cv2.cvtColor(dibujo, cv2.COLOR_BGR2HSV) \n\n   # 1. Segmentaci\u00f3n por Color (M\u00e1scara) \n   mask = cv2.inRange(hsv, bajo, alto) \n   result = cv2.bitwise_and(frame, frame, mask=mask) \n\n   # 2. Encontrar Contornos \n   lista_cont, herarquia = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE) \n\n   # 3. Identificar el Contorno M\u00e1s Grande (el objeto de inter\u00e9s principal) \n   area_grande = 0 \n   contorno_pelota = None \n   if lista_cont: \n       for contn in lista_cont: \n           area = cv2.contourArea(contn) \n           if (area &gt; area_grande): \n               area_grande = area \n               contorno_pelota = contn \n\n   # 4. Calcular Centro y Radio del C\u00edrculo Envolvente \n   if contorno_pelota is not None: \n       (x,y),radio = cv2.minEnclosingCircle(contorno_pelota) \n\n       # Dibujar el c\u00edrculo y el punto central de seguimiento \n       cv2.circle(frame,(int(x),int(y)),int(radio),(0,255,0),3) \n       cv2.circle(frame,(int(x),int(y)),3, (0,255,0),3) \n\n       # 5. Calcular el Error (Desviaci\u00f3n respecto al centro del frame) \n       h = frame.shape[0]  \n       w = frame.shape[1]  \n\n       errorx = x - (w / 2)  \n       errory = y - (h / 2)  \n\n       print(f\"ErrorX: {errorx:.1f}, ErrorY: {errory:.1f}\") \n\n       # 6. Imprimir la Direcci\u00f3n de Correcci\u00f3n (L\u00f3gica de control) \n       if (errorx &gt; 0): \n           print(\"IZQUIERDA\") # El objeto est\u00e1 a la derecha del centro (ErrorX positivo), el robot debe girar a la IZQUIERDA. \n       elif(errorx &lt; 0): \n           print(\"DERECHA\") # El objeto est\u00e1 a la izquierda del centro (ErrorX negativo), el robot debe girar a la DERECHA. \n\n       if (errory &gt; 0): \n           print(\"ABAJO\") \n       elif(errory &lt; 0): \n           print(\"ARRIBA\") \n\n   time.sleep(0.5) \n\n   # Visualizaciones en tiempo real \n   cv2.imshow(\"MASK (Blanco: Azul detectado)\", mask) \n   cv2.imshow(\"Objeto Azul sobre Fondo Negro\", result) \n   cv2.imshow(\"Video Original (Tracking)\", frame) \n\n   if cv2.waitKey(1) &amp; 0xFF == ord('q'): \n       break \n\nvideo.release() \ncv2.destroyAllWindows() \n</code></pre>"},{"location":"camara/#42-tracking-con-bluetooth","title":"4.2 Tracking con Bluetooth","text":"<p>Este es el ejercicio m\u00e1s avanzado, ya que extiende la l\u00f3gica de tracking local a\u00f1adiendo la comunicaci\u00f3n serial inal\u00e1mbrica mediante un socket Bluetooth. El script env\u00eda comandos direccionales (IZQUIERDA, DERECHA, CENTRO, etc.) a un dispositivo externo (como un microcontrolador ESP32 o Arduino con m\u00f3dulo Bluetooth), permitiendo el control aut\u00f3nomo de un robot o actuador basado en la visi\u00f3n por computadora. </p> <pre><code>import cv2 \nimport numpy as np \nimport time \nimport bluetooth  \n\n# ======== CONEXI\u00d3N BLUETOOTH CON ESP32 ======== \n\nport = 1 \n# Crea el socket Bluetooth usando el protocolo RFCOMM (usado para serial) \nsock = bluetooth.BluetoothSocket(bluetooth.RFCOMM)  \nsock.settimeout(20) \n\nMAC_ADDRESS = \"10:06:1C:97:72:DA\" # &lt;-- \u00a1REEMPLAZAR CON TU DIRECCI\u00d3N MAC! \n\nprint(\"Intentando conectar con el ESP32...\") \nwhile True: \n   try: \n       # Intenta conectar con la direcci\u00f3n MAC y el puerto especificados \n       sock.connect((MAC_ADDRESS, port))  \n       print(\"\u00a1Conectado al ESP32!\") \n       break \n   except Exception as e: \n       print(f\"Error en la conexi\u00f3n. Reintentando: {e}\") \n   time.sleep(1) \n\n\n# ======== CONFIGURACI\u00d3N DE LA C\u00c1MARA Y DETECCI\u00d3N ======== \n\nvideo = cv2.VideoCapture(0) \n\n# Rango de color azul en HSV \nbajo = np.array([90, 50, 20], dtype=np.uint8) \nalto = np.array([145, 255, 255], dtype=np.uint8) \n\n\nwhile True: \n   ret, frame = video.read() \n   if not ret: \n       break \n\n   dibujo = frame.copy() \n   hsv = cv2.cvtColor(dibujo, cv2.COLOR_BGR2HSV) \n   mask = cv2.inRange(hsv, bajo, alto) \n   result = cv2.bitwise_and(frame, frame, mask=mask) \n\n   lista_cont, herarquia = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE) \n\n   # L\u00f3gica de Detecci\u00f3n de Contorno (Buscar el m\u00e1s grande) \n   if len(lista_cont) &gt; 0: \n       area_grande = 0 \n       contorno_pelota = None \n       for contn in lista_cont: \n           area = cv2.contourArea(contn) \n           if area &gt; area_grande: \n               area_grande = area \n               contorno_pelota = contn \n\n       if contorno_pelota is not None: \n           (x, y), radio = cv2.minEnclosingCircle(contorno_pelota) \n\n           # Dibujar en el frame para visualizaci\u00f3n \n           cv2.circle(frame, (int(x), int(y)), int(radio), (0, 255, 0), 3) \n           cv2.circle(frame, (int(x), int(y)), 3, (0, 255, 0), 3) \n\n           h = frame.shape[0] \n           w = frame.shape[1] \n\n           errorx = x - (w / 2) # Desviaci\u00f3n horizontal \n           errory = y - (h / 2) # Desviaci\u00f3n vertical \n\n           # ======== ENV\u00cdO DE COMANDOS AL ESP32 ======== \n           try: \n               # Umbrales de correcci\u00f3n (50 p\u00edxeles): Evita el \"ruido\" \n               if errorx &gt; 50: \n                   mensaje = \"IZQUIERDA\"  \n               elif errorx &lt; -50: \n                   mensaje = \"DERECHA\"  \n               elif errory &lt; -50: \n                   mensaje = \"ARRIBA\"  \n               elif errory &gt; 50: \n                   mensaje = \"ABAJO\"  \n               else: \n                   mensaje = \"CENTRO\"  \n\n               # Env\u00edo del mensaje codificado a trav\u00e9s del socket \n               sock.send(mensaje.encode('utf-8')) \n               print(\"Enviado:\", mensaje) \n\n           except Exception as e: \n               print(\"Error al enviar datos:\", e) \n\n   # ======== MOSTRAR RESULTADOS ======== \n   cv2.imshow(\"MASK (Blanco: Azul detectado)\", mask) \n   cv2.imshow(\"Objeto Azul sobre Fondo Negro\", result) \n   cv2.imshow(\"Video Original (Tracking + Bluetooth)\", frame) \n\n   if cv2.waitKey(1) &amp; 0xFF == ord('q'): \n       break \n\n   time.sleep(0.3) # Controla la velocidad de procesamiento y comandos \n\nvideo.release() \ncv2.destroyAllWindows() \nsock.close() # Cierra la conexi\u00f3n Bluetooth \n</code></pre>"},{"location":"camara/#conclusion-y-futuro","title":"Conclusion y futuro","text":"<p>El desarrollo de este portafolio subraya la capacidad esencial de OpenCV y Python para transformar una fuente de video cruda en datos procesables, abarcando desde la manipulaci\u00f3n b\u00e1sica de p\u00edxeles (filtros y conversi\u00f3n de color BGR a HSV) hasta la implementaci\u00f3n de complejos algoritmos de Visi\u00f3n por Computadora (CV) para el seguimiento de objetos (tracking). La pr\u00e1ctica m\u00e1s significativa fue la exitosa integraci\u00f3n de la CV con la comunicaci\u00f3n inal\u00e1mbrica (Bluetooth), demostrando c\u00f3mo calcular el error direccional (ErrorX, ErrorY) de un objeto de inter\u00e9s y convertir esa desviaci\u00f3n en comandos de control (IZQUIERDA, DERECHA). Este proceso establece un puente funcional entre el mundo digital (visi\u00f3n) y el mundo f\u00edsico (rob\u00f3tica), siendo el principio rector de los sistemas de automatizaci\u00f3n y el control rob\u00f3tico basado en visi\u00f3n.</p>"},{"location":"controlmotores/","title":"Actividades: Control de Motores DC con ESP32 y Puente H","text":""},{"location":"controlmotores/#practica-1-control-de-direccion-de-un-motor-dc-con-esp32-y-puente-h","title":"Pr\u00e1ctica 1: Control de direcci\u00f3n de un motor DC con ESP32 y puente H","text":"<p>Equipo: Gerardo Esquivel de Luna, Jos\u00e9 Ismael Guerrero Rom\u00e1n.</p> <p>Fecha: 03/10/25</p> <p>Descripci\u00f3n: Se us\u00f3 un ESP32 y un puente H (L298N) para controlar un motor DC, haciendo que girara hacia adelante y hacia atr\u00e1s, con peque\u00f1as pausas entre cada cambio de direcci\u00f3n.</p>"},{"location":"controlmotores/#objetivos","title":"Objetivos:","text":"<ul> <li>General: Controlar el giro de un motor DC usando un puente H conectado al ESP32.</li> <li>Configurar los pines del ESP32 como salidas digitales.</li> <li>Programar el control de sentido (adelante/atr\u00e1s).</li> <li>Implementar pausas de parada entre los cambios de direcci\u00f3n.</li> </ul>"},{"location":"controlmotores/#requisitos","title":"Requisitos:","text":"<p>Software:  - Arduino IDE 2.x o superior. - Librer\u00eda ESP32.</p> <p>Hardware: - ESP32 DevKit. - Puente H L298N. - Motor DC de 6 V. - Fuente externa de 6 V. - Cables Dupont / protoboard.</p>"},{"location":"controlmotores/#codigo","title":"C\u00f3digo:","text":"<pre><code>#define in1 27\n#define in2 14\n\nvoid setup() {\n  /* Declarar pines como salida */\n  pinMode(in1, OUTPUT);\n  pinMode(in2, OUTPUT);\n}\n\nvoid loop() {\n  /* ADELANTE */\n  digitalWrite(in1, LOW);\n  digitalWrite(in2, HIGH);\n  delay(1000);\n\n  /* ALTO */\n  digitalWrite(in1, LOW);\n  digitalWrite(in2, LOW);\n  delay(1000);\n\n  /* ATR\u00c1S */\n  digitalWrite(in1, HIGH);\n  digitalWrite(in2, LOW);\n  delay(1000);\n\n  /* ALTO */\n  digitalWrite(in1, LOW);\n  digitalWrite(in2, LOW);\n  delay(1000);\n}\n</code></pre>"},{"location":"controlmotores/#video","title":"Video","text":""},{"location":"controlmotores/#practica-2-control-de-potencia-de-un-motor-dc-con-esp32-y-pwm","title":"Pr\u00e1ctica 2: Control de potencia de un motor DC con ESP32 y PWM","text":"<p>Equipo: Gerardo Esquivel de Luna, Jos\u00e9 Ismael Guerrero Rom\u00e1n.</p> <p>Fecha: 10/10/25</p> <p>Descripci\u00f3n: Se us\u00f3 un ESP32 junto con un puente H (L298N) con una fuente de 6 V para controlar la velocidad de un motor DC usando PWM, haciendo que su potencia bajara poco a poco del m\u00e1ximo al m\u00ednimo.</p>"},{"location":"controlmotores/#objetivos_1","title":"Objetivos:","text":"<ul> <li>General: Ajustar la velocidad de un motor DC usando se\u00f1ales PWM que salen del ESP32.</li> <li>Configurar un canal PWM en el ESP32 con la frecuencia y resoluci\u00f3n adecuadas.</li> <li>Implementar un programa que incremente y luego disminuya la velocidad del motor.</li> <li>Observar y analizar la respuesta del motor ante los diferentes niveles de potencia.</li> </ul>"},{"location":"controlmotores/#requisitos_1","title":"Requisitos:","text":"<p>Software:  - Arduino IDE 2.x o superior. - Librer\u00eda del ESP32 instalada desde el Gestor de Placas.</p> <p>Hardware: - ESP32 DevKit. - Puente H L298N. - Motor DC de 6 V. - Fuente externa de 6 V. - Protoboard y cables Dupont.</p>"},{"location":"controlmotores/#codigo_1","title":"C\u00f3digo:","text":"<pre><code>#define IN1 27\n#define IN2 14\n#define PWM_PIN 12\n\n// Configuraci\u00f3n del canal PWM\n#define PWM_CHANNEL 0\n#define PWM_FREQ 1000   // Frecuencia de 1 kHz\n#define PWM_RES 8       // Resoluci\u00f3n de 8 bits (valores 0 a 255)\n\nvoid setup() {\n  /* Configurar pines de salida */\n  pinMode(IN1, OUTPUT);\n  pinMode(IN2, OUTPUT);\n\n  /* Configurar canal PWM */\n  ledcSetup(PWM_CHANNEL, PWM_FREQ, PWM_RES);\n\n  /* Asociar el pin f\u00edsico al canal PWM */\n  ledcAttachPin(PWM_PIN, PWM_CHANNEL);\n}\n\nvoid loop() {\n  /* GIRO HACIA ADELANTE */\n  digitalWrite(IN1, LOW);\n  digitalWrite(IN2, HIGH);\n\n  /* Aumentar gradualmente la velocidad */\n  for (int i = 0; i &lt;= 255; i++) {\n    ledcWrite(PWM_CHANNEL, i);\n    delay(10);  // Aumento progresivo\n  }\n\n  /* Mantener velocidad m\u00e1xima */\n  delay(1000);\n\n  /* Disminuir gradualmente la velocidad */\n  for (int i = 255; i &gt;= 0; i--) {\n    ledcWrite(PWM_CHANNEL, i);\n    delay(10);  // Disminuci\u00f3n progresiva\n  }\n\n  /* Detener el motor */\n  digitalWrite(IN1, LOW);\n  digitalWrite(IN2, LOW);\n  delay(1000);\n}\n</code></pre>"},{"location":"controlmotores/#video_1","title":"Video:","text":""},{"location":"ledesp32/","title":"Control de LED con ESP32 (bot\u00f3n, Bluetooth e intervalos)","text":"<p>Equipo: Gerardo Esquivel de Luna, Jos\u00e9 Ismael Guerrero Rom\u00e1n.</p> <p>Fecha: 19/09/25</p> <p>Descripci\u00f3n: Se program\u00f3 un ESP32 para controlar un LED de tres formas: con un bot\u00f3n, por comandos v\u00eda Bluetooth y haciendo que parpadeara solo a intervalos de tiempo definidos.</p>"},{"location":"ledesp32/#objetivos","title":"Objetivos:","text":"<ul> <li>General: Probar distintas formas de controlar un LED con el ESP32 usando un bot\u00f3n, comunicaci\u00f3n inal\u00e1mbrica y programaci\u00f3n de parpadeo.</li> <li>Programar el ESP32 para que un bot\u00f3n controle el encendido y apagado inmediato del LED.</li> <li>Configurar la comunicaci\u00f3n Bluetooth del ESP32 para que el LED responda a comandos enviados desde la terminal (\"on\" y \"off\").</li> <li>Implementar un programa que haga parpadear el LED en intervalos de tiempo definidos.</li> <li>Documentar con fotograf\u00edas y videos el c\u00f3digo y el funcionamiento de cada caso.</li> </ul>"},{"location":"ledesp32/#requisitos","title":"Requisitos:","text":"<p>Software: - Arduino IDE con soporte para ESP32. - Librer\u00edas necesarias para comunicaci\u00f3n Bluetooth. - Monitor serie o aplicaci\u00f3n de terminal Bluetooth.</p> <p>Hardware: - ESP 32. - LED +  resistencia limitadora (330 \u03a9 a 820 \u03a9). - Pulsador (bot\u00f3n). - Protoboard y cables de conexi\u00f3n. - Fuente de alimentaci\u00f3n USB (5V).</p>"},{"location":"ledesp32/#programas-esp32-control-de-led","title":"Programas ESP32: Control de LED","text":""},{"location":"ledesp32/#control-por-boton","title":"Control por Bot\u00f3n:","text":"<p>Encender y apagar con un bot\u00f3n f\u00edsico. <pre><code>const int led = 33;\nconst int btn = 27;\n\nvoid setup() {\n  Serial.begin(115200);\n  pinMode(led, OUTPUT);\n  pinMode(btn, INPUT);\n}\n\nvoid loop() {\n  int estado = digitalRead(btn);\n  if (estado == 1) {\n    digitalWrite(led, 1);  // LED encendido mientras el bot\u00f3n est\u00e9 presionado\n  } else {\n    digitalWrite(led, 0);  // LED apagado cuando no se presiona\n  }\n}\n</code></pre></p>"},{"location":"ledesp32/#control-solo-por-esp-32-intervalos-de-parpadeo","title":"Control solo por ESP 32 (intervalos de parpadeo):","text":"<p>Encender y apagar mediante c\u00f3digo, en intervalos. <pre><code>const int led = 33;\n\nvoid setup() {\n  pinMode(led, OUTPUT);\n}\n\nvoid loop() {\n  digitalWrite(led, HIGH);  // LED encendido\n  delay(2000);              // Espera 2 segundos\n  digitalWrite(led, LOW);   // LED apagado\n  delay(2000);              // Espera 2 segundos\n}\n</code></pre></p>"},{"location":"ledesp32/#control-por-bluetooth","title":"Control por Bluetooth:","text":"<p>Control del led escribiendo en una consola conectada por Bluetooth <pre><code>#include \"BluetoothSerial.h\"\nBluetoothSerial SerialBT;\n\nconst int led = 33;\n\nvoid setup() {\n  Serial.begin(115200);\n  SerialBT.begin(\"ESP32-de-los-PAPITOS\"); // Nombre del dispositivo Bluetooth\n  pinMode(led, OUTPUT);\n}\n\nvoid loop() {\n  if (SerialBT.available()) {\n    String mensaje = SerialBT.readString();\n    Serial.println(\"Recibido: \" + mensaje);\n\n    if (mensaje == \"on\") {\n      digitalWrite(led, 1);   // LED encendido por comando\n    } \n    else if (mensaje == \"off\") {\n      digitalWrite(led, 0);   // LED apagado por comando\n    }\n  }\n  delay(1000);\n}\n</code></pre></p>"},{"location":"osciloscopio/","title":"Actividad: Circuito con osciloscopio","text":""},{"location":"osciloscopio/#led-intermitente-con-temporizador-555-en-modo-astable","title":"LED intermitente con temporizador 555 en modo astable","text":"<p>Equipo: Gerardo Esquivel de Luna, Jos\u00e9 Ismael Guerrero Rom\u00e1n</p> <p>Fecha: 06/09/25</p> <p>Descripci\u00f3n: Se hizo un circuito astable con el temporizador 555 para que un LED parpadeara, pudiendo ajustar el timepo entre 1 y 5 segundos. Todo se bas\u00f3 en conceptos de electr\u00f3nica anal\u00f3gica.</p>"},{"location":"osciloscopio/#objetivos","title":"Objetivos:","text":"<p>Armar un circuito con el temporizador 555 en modo astable para hacer que un LED parpadee, pudiendo camboar el tiempo de parpadeo.</p>"},{"location":"osciloscopio/#requisitos","title":"Requisitos:","text":"<ul> <li> <p>Software: No fue necesario usar ning\u00fan software, solo una calculadora b\u00e1sica para sacar los valores de los componentes.</p> </li> <li> <p>Hardware:</p> </li> <li>CI NE555 (temporizador).</li> <li>Resistencia R1 = 1 k\u03a9.</li> <li>Resistencia R2 = 6.8 k\u03a9 + potenci\u00f3metro de 30 k\u03a9.</li> <li>Capacitor electrol\u00edtico C = 100 \u00b5F.</li> <li>Resistencia limitadora para LED (330 \u03a9 a 820 \u03a9 seg\u00fan Vcc).</li> <li>LED rojo.</li> <li>Protoboard y cables de conexi\u00f3n.</li> <li>Fuente de poder de 5 V o 9 V.</li> </ul>"},{"location":"osciloscopio/#_1","title":"Circuito con Osciloscopio","text":""},{"location":"plataforma/","title":"Proyecto Final: Plataforma - Balance de Pelota.","text":"<p>Este proyecto se centr\u00f3 en el dise\u00f1o e implementaci\u00f3n de un sistema de control de posici\u00f3n en tiempo real. El objetivo fue construir una plataforma din\u00e1mica capaz de mantener una pelota centrada sobre su superficie, contrarrestando activamente la fuerza de gravedad mediante la inclinaci\u00f3n de la base. El sistema emplea una arquitectura avanzada que combina visi\u00f3n por computadora (Python) para la detecci\u00f3n de errores y el microcontrolador ESP32 para la ejecuci\u00f3n precisa del movimiento a trav\u00e9s de servomotores.</p>"},{"location":"plataforma/#marco-teorico","title":"Marco Te\u00f3rico.","text":"<p>El proyecto se sustenta en tres pilares tecnol\u00f3gicos: la visi\u00f3n por computadora para la detecci\u00f3n de errores, el protocolo de comunicaci\u00f3n inal\u00e1mbrica y la teor\u00eda de control.</p>"},{"location":"plataforma/#1-vision-por-computadora-y-deteccion-de-posicion","title":"1. Visi\u00f3n por Computadora y Detecci\u00f3n de Posici\u00f3n:","text":"<p>Se utiliz\u00f3 Python junto con bibliotecas especializadas (como OpenCV) para capturar el stream de video de la c\u00e1mara - Procesamiento: El c\u00f3digo identifica el color o las caracter\u00edsticas de la pelota, calcula sus coordenadas (x, y) en la imagen y determina la posici\u00f3n central de la plataforma. - Error: El error de posici\u00f3n se calcula como la diferencia entre la posici\u00f3n actual de la pelota y el punto central deseado, siendo la entrada principal para el algoritmo de control.</p>"},{"location":"plataforma/#2-protocolo-de-comunicacion-bluetooth","title":"2. Protocolo de Comunicaci\u00f3n Bluetooth:","text":"<p>Para transmitir los datos del error calculados por la PC (Python) al hardware (ESP32), se emple\u00f3 la comunicaci\u00f3n Bluetooth. Esta elecci\u00f3n garantiz\u00f3 una conexi\u00f3n inal\u00e1mbrica de baja latencia necesaria para las tareas de control en tiempo real, enviando los valores del error \"x\" y \"y\" de manera continua.</p>"},{"location":"plataforma/#3-control-de-inclinacion-servomotores","title":"3. Control de Inclinaci\u00f3n (Servomotores):","text":"<p>Los servomotores fueron elegidos como actuadores por su capacidad de posicionamiento angular preciso. - Funci\u00f3n: La ESP32 recibe el error y lo traduce en \u00e1ngulos de inclinaci\u00f3n , para los dos servomotores, que controlan los ejes X y Y de la plataforma. - Control (PID): La relaci\u00f3n entre el error de posici\u00f3n y los \u00e1ngulos de los servomotores generalmente se maneja mediante un algoritmo de control Proporcional-Integral-Derivativo (PID), aunque la implementaci\u00f3n b\u00e1sica puede usar solo control Proporcional. El objetivo es que, si la pelota se mueve en la direcci\u00f3n X positiva, la plataforma se incline en la direcci\u00f3n X negativa para corregir el movimiento.</p>"},{"location":"plataforma/#materiales","title":"Materiales.","text":"<ul> <li>Microcontrolador ESP32 DevKit V</li> <li>Computadora Host</li> <li>C\u00e1mara Webcam USB</li> <li>2 Servomotores</li> <li>Base de equilibrio (acr\u00edlico, madera) y mecanismos de acoplamiento para los servos.</li> <li>M\u00f3dulo de Bluetooth Integrado (en ESP32)</li> <li>Software Python y Arduino IDE (para el c\u00f3digo del ESP32).</li> </ul> <p>## Procedimiento - Elaboracion.</p> <p>## Conexi\u00f3n y montaje.</p> <p>La plataforma mec\u00e1nica se construy\u00f3 sobre dos servomotores, permitiendo el movimiento independiente en dos ejes de inclinaci\u00f3n, y su cableado se realiz\u00f3 directamente a pines PWM digitales espec\u00edficos del ESP32 para el control de \u00e1ngulo. El flujo de datos inicia con la c\u00e1mara capturando la imagen, la cual es procesada por Python para calcular el error de posici\u00f3n; Python luego transmite los valores $x, y$ v\u00eda Bluetooth a la ESP32, donde el c\u00f3digo de Arduino los recibe e inmediatamente los utiliza para calcular y establecer el \u00e1ngulo de correcci\u00f3n de los servomotores.</p> <p> </p>"},{"location":"plataforma/#codigos","title":"C\u00f3digos:","text":""},{"location":"plataforma/#codigo-python","title":"C\u00f3digo Python:","text":"<pre><code>#PruebaBUENA - Modificado: Pelota AMARILLA y Plataforma VERDE\n\nimport cv2\nimport time\nimport numpy as np\nimport serial\nimport serial.tools.list_ports\n\n# ------------------- Configuraci\u00f3n Serial Bluetooth -------------------\nesp32_port = 'COM14'\nbaud_rate = 115200\n\nprint(\"=\" * 50)\nprint(\"Intentando conectar con ESP32...\")\nprint(f\"Puerto: {esp32_port} | Baudios: {baud_rate}\")\n\ndef listar_puertos():\n    puertos = serial.tools.list_ports.comports()\n    print(\"\\n Puertos COM disponibles:\")\n    if len(puertos) == 0:\n        print(\"  No se encontraron puertos COM\")\n    for puerto in puertos:\n        print(f\"   \u2022 {puerto.device}: {puerto.description}\")\n    print()\n\nlistar_puertos()\n\ntry:\n    esp32 = serial.Serial(esp32_port, baud_rate, timeout=1)\n    time.sleep(2)\n    print(f\" \u00a1Conectado al ESP32 en {esp32_port}!\")\nexcept serial.SerialException as e:\n    print(f\" Error de conexi\u00f3n serial: {e}\")\n    esp32 = None\nexcept Exception as e:\n    print(f\" Error inesperado: {e}\")\n    esp32 = None\n\nprint(\"=\" * 50)\n\n# ------------------- Configuraci\u00f3n c\u00e1mara -------------------\ncap = cv2.VideoCapture(1)\ncap.set(cv2.CAP_PROP_FRAME_WIDTH, 640)\ncap.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)\n\nif not cap.isOpened():\n    print(\"Error: No se pudo abrir la c\u00e1mara\")\n    exit()\n\n# ------------------- Posici\u00f3n inicial servos -------------------\ncenter_angle = 90\ncurrent_x = center_angle\ncurrent_y = center_angle\nDEAD_ZONE = 15  # Zona muerta reducida\nsmoothing = 0.3  # Suavizado reducido para respuesta m\u00e1s r\u00e1pida\n\n# ------------------- Par\u00e1metros PID ajustables -------------------\nKp = 0.15\nKi = 0.001\nKd = 0.20\n\nprev_error_x = 0\nprev_error_y = 0\nintegral_x = 0\nintegral_y = 0\n\nMAX_INTEGRAL = 50\n\n# ------------------- Par\u00e1metros de detecci\u00f3n -------------------\n# Rango HSV para plataforma VERDE (modificado)\nLOW_GREEN = np.array([35, 40, 40])      # H: 35-85 (verde), S: m\u00ednimo 40, V: m\u00ednimo 40\nHIGH_GREEN = np.array([85, 255, 255])   # Rango amplio para captar diferentes tonos de verde\nAREA_MIN_PLATAFORMA = 1000  # \u00c1rea m\u00ednima del cuadrado\n\n# Rango HSV para pelota AMARILLA (modificado)\nLOW_YELLOW = np.array([20, 100, 100])    # H: 20-35 (amarillo), S: m\u00ednimo 100, V: m\u00ednimo 100\nHIGH_YELLOW = np.array([35, 255, 255])   # Cubre tonos amarillos brillantes\nAREA_MIN_PELOTA = 200\nRADIO_MIN_PELOTA = 8\n\n# ------------------- Funci\u00f3n para limitar valores -------------------\ndef constrain(value, min_val, max_val):\n    return max(min_val, min(max_val, value))\n\n# ------------------- Callbacks para sliders -------------------\ndef update_kp(val):\n    global Kp\n    Kp = val / 100.0  # Slider 0-100, valor real 0.00-1.00\n    print(f\"Kp = {Kp:.3f}\")\n\ndef update_ki(val):\n    global Ki\n    Ki = val / 1000.0  # Slider 0-100, valor real 0.000-0.100\n    print(f\"Ki = {Ki:.4f}\")\n\ndef update_kd(val):\n    global Kd\n    Kd = val / 100.0  # Slider 0-100, valor real 0.00-1.00\n    print(f\"Kd = {Kd:.3f}\")\n\n# ------------------- Crear ventana de control -------------------\ncv2.namedWindow('Control PID')\ncv2.createTrackbar('Kp x100', 'Control PID', int(Kp * 100), 100, update_kp)\ncv2.createTrackbar('Ki x1000', 'Control PID', int(Ki * 1000), 100, update_ki)\ncv2.createTrackbar('Kd x100', 'Control PID', int(Kd * 100), 100, update_kd)\n\nprev_time = time.time()\nprint(\"=\" * 50)\nprint(\"Sistema de Balance: Plataforma VERDE + Pelota AMARILLA\")\nprint(\"=\" * 50)\nprint(\"CONFIGURACI\u00d3N:\")\nprint(f\"  \u2022 Centro servos: {center_angle}\u00b0 (Rango: 0-180\u00b0)\")\nprint(f\"  \u2022 Zona muerta: \u00b1{DEAD_ZONE} p\u00edxeles\")\nprint(f\"  \u2022 Suavizado: {smoothing}\")\nprint(f\"  \u2022 PID: Kp={Kp} Ki={Ki} Kd={Kd}\")\nprint(\"\\nDETECCI\u00d3N:\")\nprint(\"  \u2022 PLATAFORMA VERDE (HSV): Detecta \u00e1rea m\u00e1s grande de tonos verdes\")\nprint(f\"    Rango H: {LOW_GREEN[0]}-{HIGH_GREEN[0]} | S: {LOW_GREEN[1]}-{HIGH_GREEN[1]} | V: {LOW_GREEN[2]}-{HIGH_GREEN[2]}\")\nprint(\"  \u2022 PELOTA AMARILLA: Posici\u00f3n para calcular error\")\nprint(f\"    Rango H: {LOW_YELLOW[0]}-{HIGH_YELLOW[0]} | S: {LOW_YELLOW[1]}-{HIGH_YELLOW[1]} | V: {LOW_YELLOW[2]}-{HIGH_YELLOW[2]}\")\nprint(\"\\nCONTROLES:\")\nprint(\"  \u2022 'q' \u2192 Salir\")\nprint(\"  \u2022 'c' \u2192 Resetear integrales\")\nprint(\"  \u2022 Sliders \u2192 Ajustar PID en tiempo real\")\nprint(\"=\" * 50)\n\nframe_count = 0\nfps_time = time.time()\nfps = 0\n\nwhile True:\n    ret, frame = cap.read()\n    if not ret:\n        print(\"Error: No se pudo leer frame de la c\u00e1mara\")\n        break\n\n    frame = cv2.flip(frame, 1)\n    height, width = frame.shape[:2]\n    centrox, centroy = width//2, height//2\n\n    # ===============================================================\n    # DETECCI\u00d3N 1: PLATAFORMA VERDE (HSV) - \u00c1REA M\u00c1S GRANDE\n    # ===============================================================\n    hsv_plat = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)\n\n    # M\u00e1scara para detectar verde\n    mask_plataforma = cv2.inRange(hsv_plat, LOW_GREEN, HIGH_GREEN)\n\n    kernel_plat = np.ones((7,7), np.uint8)\n    mask_plataforma = cv2.morphologyEx(mask_plataforma, cv2.MORPH_CLOSE, kernel_plat)\n    mask_plataforma = cv2.morphologyEx(mask_plataforma, cv2.MORPH_OPEN, kernel_plat)\n    mask_plataforma = cv2.dilate(mask_plataforma, kernel_plat, iterations=1)\n\n    contours_plat, _ = cv2.findContours(mask_plataforma, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    area_max_plat = 0\n    contorno_plat = None\n    centro_plataforma = None\n    rectangulo_info = None\n\n    for c in contours_plat:\n        area = cv2.contourArea(c)\n        if area &gt; area_max_plat and area &gt; AREA_MIN_PLATAFORMA:\n            area_max_plat = area\n            contorno_plat = c\n            rectangulo_info = cv2.minAreaRect(c)\n\n            M = cv2.moments(c)\n            if M[\"m00\"] != 0:\n                cx_plat = int(M[\"m10\"] / M[\"m00\"])\n                cy_plat = int(M[\"m01\"] / M[\"m00\"])\n                centro_plataforma = (cx_plat, cy_plat)\n\n    # ===============================================================\n    # DETECCI\u00d3N 2: PELOTA AMARILLA\n    # ===============================================================\n    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)\n    mask_pelota = cv2.inRange(hsv, LOW_YELLOW, HIGH_YELLOW)\n\n    kernel_pelota = np.ones((5,5), np.uint8)\n    mask_pelota = cv2.morphologyEx(mask_pelota, cv2.MORPH_OPEN, kernel_pelota)\n    mask_pelota = cv2.morphologyEx(mask_pelota, cv2.MORPH_CLOSE, kernel_pelota)\n    mask_pelota = cv2.dilate(mask_pelota, kernel_pelota, iterations=1)\n\n    contours_pelota, _ = cv2.findContours(mask_pelota, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    area_max_pelota = 0\n    contorno_pelota = None\n    centro_pelota = None\n    radio_pelota = 0\n\n    for c in contours_pelota:\n        area = cv2.contourArea(c)\n        if area &gt; area_max_pelota:\n            area_max_pelota = area\n            contorno_pelota = c\n            (x_pel, y_pel), radio_pelota = cv2.minEnclosingCircle(c)\n            if radio_pelota &gt; RADIO_MIN_PELOTA and area &gt; AREA_MIN_PELOTA:\n                centro_pelota = (int(x_pel), int(y_pel))\n\n    # ===============================================================\n    # VISUALIZACI\u00d3N\n    # ===============================================================\n    out_original = frame.copy()\n\n    mask_combinada = cv2.bitwise_or(mask_plataforma, mask_pelota)\n    out_deteccion = cv2.cvtColor(mask_combinada, cv2.COLOR_GRAY2BGR)\n\n    # Verde para plataforma, Amarillo para pelota\n    out_deteccion[mask_plataforma &gt; 0] = [0, 255, 0]      # Verde\n    out_deteccion[mask_pelota &gt; 0] = [0, 255, 255]        # Amarillo (BGR: cyan visualmente amarillo en HSV)\n\n    # ===============================================================\n    # CALCULAR TIEMPO\n    # ===============================================================\n    current_time = time.time()\n    dt = current_time - prev_time\n    prev_time = current_time\n    if dt &lt; 0.001:\n        dt = 0.001\n\n    # ===============================================================\n    # CONTROL PID\n    # ===============================================================\n    plataforma_detectada = (contorno_plat is not None and area_max_plat &gt; AREA_MIN_PLATAFORMA and centro_plataforma is not None)\n    pelota_detectada = (contorno_pelota is not None and centro_pelota is not None)\n\n    if plataforma_detectada:\n        if rectangulo_info:\n            box = cv2.boxPoints(rectangulo_info)\n            box = np.intp(box)\n            cv2.drawContours(out_original, [box], 0, (0, 255, 0), 3)\n            cv2.drawContours(out_deteccion, [box], 0, (0, 255, 0), 2)\n\n        cv2.circle(out_original, centro_plataforma, 12, (0, 255, 0), 3)\n        cv2.circle(out_original, centro_plataforma, 5, (0, 255, 0), -1)\n        cv2.putText(out_original, \"PLATAFORMA\", (centro_plataforma[0]-40, centro_plataforma[1]-20),\n                   cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 0), 2)\n\n        if pelota_detectada:\n            cv2.circle(out_original, centro_pelota, int(radio_pelota), (0, 255, 255), 2)\n            cv2.circle(out_original, centro_pelota, 5, (0, 255, 255), -1)\n            cv2.putText(out_original, \"PELOTA\", (centro_pelota[0]-30, centro_pelota[1]+25),\n                       cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 255), 2)\n            cv2.line(out_original, centro_plataforma, centro_pelota, (0, 255, 255), 2)\n            cv2.line(out_deteccion, centro_plataforma, centro_pelota, (255, 255, 255), 2)\n\n            # ===============================================================\n            # CALCULAR ERROR: Pelota respecto al centro de la plataforma\n            # ===============================================================\n            error_x = -(centro_pelota[0] - centro_plataforma[0])\n            error_y = (centro_pelota[1] - centro_plataforma[1])\n\n            if abs(error_x) &lt; DEAD_ZONE:\n                error_x = 0\n            if abs(error_y) &lt; DEAD_ZONE:\n                error_y = 0\n\n            integral_x += error_x * dt\n            integral_y += error_y * dt\n            integral_x = constrain(integral_x, -MAX_INTEGRAL, MAX_INTEGRAL)\n            integral_y = constrain(integral_y, -MAX_INTEGRAL, MAX_INTEGRAL)\n\n            derivative_x = (error_x - prev_error_x) / dt\n            derivative_y = (error_y - prev_error_y) / dt\n\n            output_x = Kp*error_x + Ki*integral_x + Kd*derivative_x\n            output_y = Kp*error_y + Ki*integral_y + Kd*derivative_y\n\n            prev_error_x = error_x\n            prev_error_y = error_y\n\n            delta_x = output_x * 0.15\n            delta_y = output_y * 0.15\n\n            target_x = center_angle + delta_x\n            target_y = center_angle + delta_y\n\n            current_x = current_x * (1 - smoothing) + target_x * smoothing\n            current_y = current_y * (1 - smoothing) + target_y * smoothing\n\n            current_x = constrain(current_x, 0, 110)\n            current_y = constrain(current_y, 0, 110)\n\n            if esp32:\n                mensaje = f\"{int(current_x)},{int(current_y)}\\n\"\n                try:\n                    esp32.write(mensaje.encode())\n                    if esp32.in_waiting &gt; 0:\n                        respuesta = esp32.readline().decode('utf-8', errors='ignore').strip()\n                        if respuesta and frame_count % 30 == 0:\n                            print(f\"\ud83d\udce1 ESP32: {respuesta}\")\n                except Exception as e:\n                    if frame_count % 30 == 0:\n                        print(f\"\u2717 Error: {e}\")\n\n            if frame_count % 5 == 0:\n                print(f\"\u2713 X={int(current_x):3d}\u00b0 Y={int(current_y):3d}\u00b0 | Err X={-error_x:4d} Y={-error_y:4d} | Out X={output_x:6.1f} Y={output_y:6.1f}\")\n\n            cv2.putText(out_original, f\"Error X:{-error_x} Y:{-error_y}\", (10,30),\n                        cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255,255,0), 2)\n            cv2.putText(out_original, f\"Servo X:{int(current_x)} Y:{int(current_y)}\", (10,60),\n                        cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255,255,0), 2)\n            cv2.putText(out_original, f\"Distancia: {int(np.sqrt(error_x**2 + error_y**2))} px\", (10,90),\n                        cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0,255,255), 2)\n        else:\n            cv2.putText(out_original, \"PELOTA NO DETECTADA\", (10,30),\n                        cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0,165,255), 2)\n\n            integral_x = 0\n            integral_y = 0\n            prev_error_x = 0\n            prev_error_y = 0\n\n            current_x = current_x * (1 - smoothing*0.5) + center_angle * smoothing * 0.5\n            current_y = current_y * (1 - smoothing*0.5) + center_angle * smoothing * 0.5\n\n            if esp32 and frame_count % 10 == 0:\n                try:\n                    esp32.write(f\"{int(current_x)},{int(current_y)}\\n\".encode())\n                except:\n                    pass\n\n            if frame_count % 30 == 0:\n                print(f\"\u26a0 Solo plataforma. Centrando: X={int(current_x)}\u00b0 Y={int(current_y)}\u00b0\")\n    else:\n        cv2.putText(out_original, \"PLATAFORMA NO DETECTADA\", (10,30),\n                    cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0,0,255), 2)\n\n        integral_x = 0\n        integral_y = 0\n        prev_error_x = 0\n        prev_error_y = 0\n\n        current_x = current_x * (1 - smoothing*0.5) + center_angle * smoothing * 0.5\n        current_y = current_y * (1 - smoothing*0.5) + center_angle * smoothing * 0.5\n\n        if esp32 and frame_count % 10 == 0:\n            try:\n                esp32.write(f\"{int(current_x)},{int(current_y)}\\n\".encode())\n            except:\n                pass\n\n        if frame_count % 30 == 0:\n            print(f\"\u26a0 Sin detecci\u00f3n. Centrando: X={int(current_x)}\u00b0 Y={int(current_y)}\u00b0\")\n\n    cv2.circle(out_original, (centrox, centroy), DEAD_ZONE, (128,128,128), 1)\n    cv2.line(out_original, (centrox-15, centroy), (centrox+15, centroy), (128,128,128), 1)\n    cv2.line(out_original, (centrox, centroy-15), (centrox, centroy+15), (128,128,128), 1)\n\n    cv2.putText(out_original, f\"Plat:{int(area_max_plat)} Pel:{int(area_max_pelota)}\", (10,height-40),\n                cv2.FONT_HERSHEY_SIMPLEX, 0.5, (200,200,200), 1)\n\n    cv2.putText(out_original, f\"PID: Kp={Kp:.2f} Ki={Ki:.3f} Kd={Kd:.2f}\", (10,120),\n                cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255,200,0), 2)\n\n    frame_count += 1\n    if time.time() - fps_time &gt; 1.0:\n        fps = frame_count\n        frame_count = 0\n        fps_time = time.time()\n\n    cv2.putText(out_original, f\"FPS: {fps}\", (width-100, 30),\n                cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0,255,0), 2)\n\n    cv2.imshow(\"Sistema de Balance - Original\", out_original)\n    cv2.imshow(\"Deteccion: Plataforma(Verde) + Pelota(Amarillo)\", out_deteccion)\n\n    key = cv2.waitKey(1) &amp; 0xFF\n    if key == ord('q'):\n        break\n    elif key == ord('c'):\n        integral_x = 0\n        integral_y = 0\n        print(\"Integrales reseteadas\")\n\nprint(\"\\nCerrando sistema...\")\ncap.release()\nif esp32:\n    esp32.write(f\"{center_angle},{center_angle}\\n\".encode())\n    time.sleep(0.1)\n    esp32.close()\n    print(\"Conexi\u00f3n serial cerrada\")\ncv2.destroyAllWindows()\nprint(\"Sistema finalizado\")\n</code></pre>"},{"location":"plataforma/#codigo-arduino","title":"C\u00f3digo Arduino:","text":"<pre><code>#include &lt;ESP32Servo.h&gt;\n#include &lt;BluetoothSerial.h&gt;\n\n// =============== CONFIGURACI\u00d3N BLUETOOTH ===============\nString device_name = \"ESP32-BT-Slave\";\nBluetoothSerial SerialBT;\n\n// =============== CONFIGURACI\u00d3N DE PINES ===============\nconst int PIN_SERVO_X = 18;\nconst int PIN_SERVO_Y = 19;\n\n// =============== CONFIGURACI\u00d3N DE SERVOS ===============\nServo servoX;\nServo servoY;\n\nconst int PWM_MIN = 500;\nconst int PWM_MAX = 2400;\n\n// =============== POSICI\u00d3N INICIAL (CENTRADA) ===============\nconst int CENTRO = 90;\n\n// =============== VARIABLES DE COMUNICACI\u00d3N ===============\nString inputString = \"\";\nbool stringComplete = false;\n\n// =============== VARIABLES DE CONTROL ===============\nint posicionX = CENTRO;\nint posicionY = CENTRO;\nunsigned long ultimoComando = 0;\nconst unsigned long TIMEOUT = 2000;\n\n// =============== VARIABLES DE DEBUG ===============\nunsigned long contadorComandos = 0;\nunsigned long ultimoDebug = 0;\nconst unsigned long INTERVALO_DEBUG = 1000;\n\n// =============== CONFIGURACI\u00d3N INICIAL ===============\nvoid setup() {\n  // Iniciar Serial USB (para debug)\n  Serial.begin(115200);\n  delay(100);\n\n  // Iniciar Bluetooth Serial\n  SerialBT.begin(device_name);\n  delay(500);\n\n  inputString.reserve(20);\n\n  // Configurar timers del ESP32\n  ESP32PWM::allocateTimer(0);\n  ESP32PWM::allocateTimer(1);\n  ESP32PWM::allocateTimer(2);\n  ESP32PWM::allocateTimer(3);\n\n  // Configurar servos\n  servoX.attach(PIN_SERVO_X, PWM_MIN, PWM_MAX);\n  servoY.attach(PIN_SERVO_Y, PWM_MIN, PWM_MAX);\n\n  // Mover a posici\u00f3n inicial (CENTRO)\n  Serial.println(\"\\n========================================\");\n  Serial.println(\"Inicializando servos en posicion central...\");\n  servoX.write(CENTRO);\n  servoY.write(CENTRO);\n  delay(1000);\n  Serial.println(\"Servos centrados!\");\n\n  // Mensaje de inicio (USB)\n  Serial.println(\"========================================\");\n  Serial.println(\"ESP32 - Sistema de Balance BLUETOOTH\");\n  Serial.println(\"========================================\");\n  Serial.print(\"Nombre Bluetooth: \");\n  Serial.println(device_name);\n  Serial.print(\"Servo X en GPIO \");\n  Serial.println(PIN_SERVO_X);\n  Serial.print(\"Servo Y en GPIO \");\n  Serial.println(PIN_SERVO_Y);\n  Serial.print(\"Posicion inicial: \");\n  Serial.print(CENTRO);\n  Serial.println(\" grados\");\n  Serial.println(\"========================================\");\n  Serial.println(\"Esperando conexion Bluetooth...\");\n  Serial.println(\"========================================\\n\");\n\n  // Mensaje de inicio (Bluetooth)\n  SerialBT.println(\"ESP32 Balance System Ready\");\n  SerialBT.println(\"Servos centrados en 90 grados\");\n  SerialBT.println(\"Esperando comandos...\");\n\n  ultimoComando = millis();\n  ultimoDebug = millis();\n}\n\n// =============== BUCLE PRINCIPAL ===============\nvoid loop() {\n  // Leer datos desde Bluetooth\n  while (SerialBT.available()) {\n    char inChar = (char)SerialBT.read();\n\n    if (inChar == '\\n' || inChar == '\\r') {\n      if (inputString.length() &gt; 0) {\n        stringComplete = true;\n      }\n    } else {\n      inputString += inChar;\n    }\n  }\n\n  // Procesar comando si est\u00e1 completo\n  if (stringComplete) {\n    procesarComando();\n    inputString = \"\";\n    stringComplete = false;\n    ultimoComando = millis();\n  }\n\n  // Debug peri\u00f3dico (solo por USB)\n  if (millis() - ultimoDebug &gt; INTERVALO_DEBUG) {\n    mostrarEstado();\n    ultimoDebug = millis();\n  }\n\n  // Timeout - volver al centro si no hay comandos\n  if (millis() - ultimoComando &gt; TIMEOUT) {\n    volverAlCentro();\n  }\n}\n\n// =============== FUNCI\u00d3N: PROCESAR COMANDO ===============\nvoid procesarComando() {\n  contadorComandos++;\n\n  // Debug por USB\n  Serial.print(\"[BT-CMD #\");\n  Serial.print(contadorComandos);\n  Serial.print(\"] '\");\n  Serial.print(inputString);\n  Serial.print(\"' -&gt; \");\n\n  int comaIndex = inputString.indexOf(',');\n\n  if (comaIndex &gt; 0) {\n    String valorXStr = inputString.substring(0, comaIndex);\n    String valorYStr = inputString.substring(comaIndex + 1);\n\n    int xRecibido = valorXStr.toInt();\n    int yRecibido = valorYStr.toInt();\n\n    // Debug\n    Serial.print(\"X=\");\n    Serial.print(xRecibido);\n    Serial.print(\" Y=\");\n    Serial.print(yRecibido);\n\n    // Validar y limitar (0-180 grados)\n    xRecibido = constrain(xRecibido, 0, 180);\n    yRecibido = constrain(yRecibido, 0, 180);\n\n    // Mostrar cambio\n    if (xRecibido != posicionX || yRecibido != posicionY) {\n      Serial.print(\" | Moviendo: X(\");\n      Serial.print(posicionX);\n      Serial.print(\"\u2192\");\n      Serial.print(xRecibido);\n      Serial.print(\"\u00b0) Y(\");\n      Serial.print(posicionY);\n      Serial.print(\"\u2192\");\n      Serial.print(yRecibido);\n      Serial.println(\"\u00b0)\");\n    } else {\n      Serial.println(\" | Sin cambio\");\n    }\n\n    // Actualizar posiciones\n    posicionX = xRecibido;\n    posicionY = yRecibido;\n\n    // Mover servos a las nuevas posiciones\n    servoX.write(posicionX);\n    servoY.write(posicionY);\n\n    // Confirmaci\u00f3n por Bluetooth a Python\n    SerialBT.print(\"OK: \");\n    SerialBT.print(posicionX);\n    SerialBT.print(\",\");\n    SerialBT.println(posicionY);\n\n  } else {\n    Serial.println(\"ERROR - Formato invalido\");\n    SerialBT.println(\"Error: Formato invalido. Use X,Y\");\n  }\n}\n\n// =============== FUNCI\u00d3N: MOSTRAR ESTADO ===============\nvoid mostrarEstado() {\n  if (SerialBT.hasClient()) {\n    Serial.print(\"[ESTADO] BT conectado | X=\");\n  } else {\n    Serial.print(\"[ESTADO] BT desconectado | X=\");\n  }\n  Serial.print(posicionX);\n  Serial.print(\"\u00b0 Y=\");\n  Serial.print(posicionY);\n  Serial.print(\"\u00b0 | Cmds: \");\n  Serial.print(contadorComandos);\n  Serial.print(\" | Sin datos: \");\n  Serial.print((millis() - ultimoComando) / 1000);\n  Serial.println(\"s\");\n}\n\n// =============== FUNCI\u00d3N: VOLVER AL CENTRO ===============\nvoid volverAlCentro() {\n  static bool mensajeMostrado = false;\n  static unsigned long ultimoCentrado = 0;\n\n  if (millis() - ultimoCentrado &lt; 500) {\n    return;\n  }\n  ultimoCentrado = millis();\n\n  if (posicionX != CENTRO || posicionY != CENTRO) {\n    if (!mensajeMostrado) {\n      Serial.println(\"\\n[TIMEOUT] Volviendo al centro...\");\n      SerialBT.println(\"Timeout: Centrando servos...\");\n      mensajeMostrado = true;\n    }\n\n    // Movimiento gradual al centro\n    if (posicionX &lt; CENTRO) posicionX += 2;\n    if (posicionX &gt; CENTRO) posicionX -= 2;\n    if (posicionY &lt; CENTRO) posicionY += 2;\n    if (posicionY &gt; CENTRO) posicionY -= 2;\n\n    // Ajuste fino\n    if (abs(posicionX - CENTRO) == 1) posicionX = CENTRO;\n    if (abs(posicionY - CENTRO) == 1) posicionY = CENTRO;\n\n    servoX.write(posicionX);\n    servoY.write(posicionY);\n\n    Serial.print(\"  Centrando: X=\");\n    Serial.print(posicionX);\n    Serial.print(\"\u00b0 Y=\");\n    Serial.print(posicionY);\n    Serial.println(\"\u00b0\");\n  } else {\n    if (mensajeMostrado) {\n      Serial.println(\"[CENTRADO] Completo\\n\");\n      mensajeMostrado = false;\n      ultimoComando = millis();\n    }\n  }\n</code></pre>"},{"location":"plataforma/#resultados","title":"Resultados","text":"<p>La validaci\u00f3n del sistema se centr\u00f3 en tres subsistemas clave. En cuanto a la Visi\u00f3n, la plataforma demostr\u00f3 ser capaz de calcular el error de posici\u00f3n $(x, y)$ de la pelota con la precisi\u00f3n necesaria para la tarea de equilibrio. La Conectividad se confirm\u00f3 con el establecimiento y mantenimiento de una conexi\u00f3n Bluetooth estable entre la PC y el ESP32, presentando una latencia lo suficientemente baja para ejecutar las correcciones de la plataforma de manera r\u00e1pida y efectiva. Finalmente, el Control de Posici\u00f3n fue exitoso, ya que el sistema logr\u00f3 mover la pelota desde cualquier posici\u00f3n inicial descentrada hacia el punto central y, m\u00e1s importante a\u00fan, cumpli\u00f3 el objetivo principal: mantener el objeto en equilibrio sobre la plataforma por un tiempo prolongado, contrarrestando eficientemente cualquier perturbaci\u00f3n.</p>"},{"location":"plataforma/#conclusiones","title":"Conclusiones","text":"<p>El proyecto de Plataforma de Balanceo de Bola demostr\u00f3 la aplicaci\u00f3n efectiva de la ingenier\u00eda de control y la visi\u00f3n por computadora. Se logr\u00f3 integrar con \u00e9xito tres dominios: el procesamiento de alto nivel (Python/OpenCV), la comunicaci\u00f3n inal\u00e1mbrica (Bluetooth) y el control de actuadores de precisi\u00f3n (Servomotores/ESP32). Este sistema valida la capacidad de la arquitectura PC-Microcontrolador para resolver problemas de control din\u00e1mico que requieren un alto poder de c\u00f3mputo para la detecci\u00f3n de errores.</p>"},{"location":"presentacion/","title":"Presentacion del equipo","text":""},{"location":"presentacion/#nosotros-somos","title":"NOSOTROS SOMOS","text":""},{"location":"presentacion/#gerardo-esquivel","title":"Gerardo Esquivel","text":""},{"location":"presentacion/#_1","title":"Equipo de trabajo","text":"<ul> <li> <p>Carrera: Ing. Mecatr\u00f3nica</p> </li> <li> <p>De donde vengo: Soy de Puebla</p> </li> <li> <p>Cosas que me gustan: Bicicleta, videojuegos, monta\u00f1ismo, animales</p> </li> <li> <p>Algo de lo que estoy orgulloso: Ser una persona perseverante, que no se rinde f\u00e1cilmente, por haber superado momentos dif\u00edciles y seguir avanzando y por ser alguien que ayuda a los dem\u00e1s cuando lo necesitan</p> </li> <li> <p>Edad: 18 a\u00f1os</p> </li> <li> <p>Cumplea\u00f1os: 18 de julio</p> </li> <li> <p>Contacto: 204655@iberopuebla.mx (institucional)</p> </li> </ul>"},{"location":"presentacion/#ismael-guerrero","title":"Ismael Guerrero","text":""},{"location":"presentacion/#_2","title":"Equipo de trabajo","text":"<ul> <li> <p>Carrera:Ing. Mecatr\u00f3nica</p> </li> <li> <p>De donde vengo: Soy de Puebla</p> </li> <li> <p>Cosas que me gustan: Videojuegos, m\u00fasica, formula 1, tecnolog\u00eda</p> </li> <li> <p>Algo de lo que estoy orgulloso: De como he crecido como persona y como a pesar de mis errores y aciertos en la vida he podido levantarme y aprender, tambien de las personas que me rodean y como he podido influir positivamente en ellos, tambien estoy orgulloso de haber tenido una buena trayectoria academica y de poder seguir estudiando</p> </li> <li> <p>Edad: 18 a\u00f1os</p> </li> <li> <p>Cumplea\u00f1os: 23 de julio</p> </li> <li> <p>Contacto: 203563@iberopuebla.mx</p> </li> </ul>"},{"location":"proyectos/","title":"Proyecto medio semestre: Coches Robots - Partido de f\u00fatbol","text":""},{"location":"proyectos/#objetivo","title":"Objetivo","text":"<p>El proyecto consisti\u00f3 en el dise\u00f1o y construcci\u00f3n de un carro robot teledirigido cuyo principal prop\u00f3sito era competir exitosamente en un torneo de f\u00fatbol de robots, enfoc\u00e1ndose en la alta maniobrabilidad para manipular la pelota y marcar goles. La arquitectura t\u00e9cnica se bas\u00f3 en el microcontrolador ESP32 para el control, implementando un sistema de direcci\u00f3n inal\u00e1mbrica que utiliza un mando de PS4 conectado v\u00eda Bluetooth.</p>"},{"location":"proyectos/#arquitectura-tecnologia-marco-teorico","title":"Arquitectura - Tecnolog\u00eda: Marco te\u00f3rico","text":"<ul> <li>Microcontrolador: Se eligi\u00f3 el ESP32 espec\u00edficamente por su arquitectura de doble n\u00facleo y, lo m\u00e1s importante, su conectividad Bluetooth integrada, crucial para recibir comandos inal\u00e1mbricos y en tiempo real desde el controlador de PlayStation.</li> <li>Driver de Motor: Se emple\u00f3 un Puente H (como el L298N) para actuar como interfaz de potencia, ya que el ESP32 no tiene la capacidad de suministrar la alta corriente requerida por los motores DC.</li> <li>Movimiento: La cinem\u00e1tica implementada fue la de Tracci\u00f3n Diferencial. Esta se logr\u00f3 enviando se\u00f1ales de PWM (Modulaci\u00f3n por Ancho de Pulso) a los motores, permitiendo movimientos precisos como el avance, retroceso y giros controlados.</li> </ul>"},{"location":"proyectos/#materiales","title":"Materiales","text":"<ul> <li>ESP 32: La unidad central de procesamiento y gesti\u00f3n de la comunicaci\u00f3n Bluetooth.</li> <li>PUENTE H: Proporcionar la potencia adecuada para la operaci\u00f3n de los motores.</li> <li>CONTROL PS4: La interfaz de control remoto para emitir comandos de movimiento.</li> <li>Pilas 3.7V / 2600 mAh: Suministro de energ\u00eda al sistema.</li> <li>MOTORES DC: Elementos actuadores que proporcionan la tracci\u00f3n.</li> <li>MDF / IMPRESION 3D: Materiales utilizados para la estructura (chasis, cubiertas y pala frontal).</li> </ul> <p>## Procedimiento - Elaboraci\u00f3n</p> <p>El desarrollo del proyecto se llev\u00f3 a cabo mediante una aproximaci\u00f3n colaborativa, dividida en las siguientes \u00e1reas de especializaci\u00f3n</p> <ul> <li>Electronica: Este equipo se encarg\u00f3 de la planificaci\u00f3n y montaje del circuito, incluyendo el dise\u00f1o del diagrama, la conexi\u00f3n segura del driver de motor, la integraci\u00f3n de fusibles, el sistema de bater\u00edas y el cableado general del robot.</li> <li>Programacion: Se centr\u00f3 en el desarrollo del firmware necesario para establecer la conexi\u00f3n Bluetooth con el control y, vitalmente, crear la l\u00f3gica de control de motores, que traduce las entradas del joystick en las se\u00f1ales de movimiento deseadas.</li> <li>Mecanica: Esta \u00e1rea fue responsable del dise\u00f1o f\u00edsico (chasis de cuatro ruedas) y el ensamblaje, incluyendo la creaci\u00f3n e integraci\u00f3n de la pala frontal dise\u00f1ada para la interacci\u00f3n eficiente con la pelota.</li> </ul> <p> </p> <p>## Codigo de programaci\u00f3n (Arduino)</p> <p>Este firmware gestiona la conexi\u00f3n con el control PS4 y utiliza la l\u00f3gica de tracci\u00f3n diferencial y ajuste de velocidad (con el gatillo R2) para el control del carro.</p> <pre><code>/**\n * @file Robot_Futbol_PS4_ESP32.ino\n * @brief C\u00f3digo para controlar un carro robot de f\u00fatbol usando un ESP32 y un control PS4.\n * Incluye funciones para avance, retroceso, giros y tracci\u00f3n diferencial mediante Joysticks.\n */\n\n// Bibliotecas necesarias:\n#include &lt;Arduino.h&gt;\n#include &lt;PS4Controller.h&gt; \n\n// --- Configuraci\u00f3n de Pines y Variables ---\nint enA = 25; int enB = 14; // Pines de Enable (PWM)\nint IN1 = 26; int IN2 = 27; int IN3 = 32; int IN4 = 33; // Pines de Direcci\u00f3n\n#define R 0 // Canal LEDC para Motor Derecho\n#define L 1 // Canal LEDC para Motor Izquierdo\nint Speed = 210; // Velocidad base inicial\nint threshold = 10; // Umbral de sensibilidad para Joysticks\n\n// --- Declaraci\u00f3n de Funciones de Movimiento ---\nvoid forward(); void backward(); void left(); void right(); void stop();\nvoid setMotor(int leftMotor, int rightMotor);\n\n// --- Setup (Configuraci\u00f3n Inicial) ---\nvoid setup() {\n    Serial.begin(115200);\n    // *IMPORTANTE*: Reemplace la MAC Address con la de su control PS4.\n    PS4.begin(\"98:3b:8f:fc:0c:82\"); \n    Serial.println(\"Esperando control PS4...\");\n    ledcAttachChannel(enA, 5000, 8, R);\n    ledcAttachChannel(enB, 5000, 8, L);\n    pinMode(IN1, OUTPUT); pinMode(IN2, OUTPUT);\n    pinMode(IN3, OUTPUT); pinMode(IN4, OUTPUT);\n    stop();\n}\n\n// --- Loop Principal (Ejecuci\u00f3n Continua) ---\nvoid loop() {\n    if (PS4.isConnected()) {\n        // 1. Ajuste de Velocidad con R2\n        Speed = map(PS4.R2Value(), 0, 255, 210, 255);\n</code></pre>"},{"location":"proyectos/#conclusion-y-resultados","title":"Conclusion y Resultados","text":"<p>El proyecto finaliz\u00f3 con \u00e9xito, resultando en un veh\u00edculo rob\u00f3tico completamente funcional que no solo cumpli\u00f3 con los requisitos de dise\u00f1o, sino que tambi\u00e9n demostr\u00f3 un desempe\u00f1o excepcional en el torneo de \"F\u00fatbol de Coches\", donde el equipo result\u00f3 ganador. La verificaci\u00f3n funcional confirm\u00f3 la estabilidad del movimiento lineal y la alta maniobrabilidad lograda mediante el sistema de tracci\u00f3n diferencial y se\u00f1ales PWM precisas. Adem\u00e1s, la conexi\u00f3n Bluetooth entre el control de PlayStation y el ESP32 mantuvo una latencia m\u00ednima, permitiendo un control en tiempo real que fue decisivo para el \u00e9xito ofensivo (anotando aproximadamente 4 goles). </p>"},{"location":"servos/","title":"Control Angular de Servomotor con ESP32","text":"<p>El prop\u00f3sito fundamental de esta pr\u00e1ctica fue analizar y aplicar los principios operativos de un servomotor utilizando las capacidades de generaci\u00f3n de se\u00f1al PWM de la placa ESP32. El objetivo espec\u00edfico se centr\u00f3 en la secuenciaci\u00f3n precisa del eje del servo a tres \u00e1ngulos clave predefinidos: 0\u00b0, 90\u00b0 y 180\u00b0, asegurando un movimiento controlado y repetitivo.</p>"},{"location":"servos/#fundamentos-teoricos","title":"Fundamentos te\u00f3ricos","text":"<p>Los servomotores son dispositivos actuadores fundamentales en la rob\u00f3tica, conocidos por su capacidad para lograr un control angular exacto dentro de un rango limitado (com\u00fanmente 180\u00b0). El control de su posici\u00f3n se realiza a trav\u00e9s de la Modulaci\u00f3n por Ancho de Pulso (PWM), donde el ancho del pulso el\u00e9ctrico (ciclo de trabajo) que reciben es directamente proporcional al \u00e1ngulo de giro deseado.</p>"},{"location":"servos/#con-esp-32","title":"Con ESP 32","text":"<p>El microcontrolador ESP32 es id\u00f3neo para esta tarea, ya que su hardware permite una generaci\u00f3n de se\u00f1ales PWM altamente configurable en t\u00e9rminos de resoluci\u00f3n y frecuencia. Para la programaci\u00f3n, se emplean dos funciones esenciales del framework de Arduino: 1.  ledcWrite(): Se utiliza para enviar el valor del ciclo de trabajo PWM al pin de salida. 2.  map(): Es crucial para realizar la conversi\u00f3n matem\u00e1tica del rango de grados legible por el usuario (0 a 180) al rango espec\u00edfico de valores PWM que el servo interpreta.</p>"},{"location":"servos/#materiales","title":"Materiales","text":"<ul> <li>ESP 32: Microcontrolador principal</li> <li>Servomotor: Actuador de control angular</li> <li>Protoboard: Plataforma para el ensamblaje del circuito</li> <li>Jumpers: Cables conectores</li> <li>Fuente de alimentaci\u00f3n: Suministro de energ\u00eda independiente para el servo.</li> <li>PC con IDE (Arduino) y cable para ESP</li> </ul>"},{"location":"servos/#montaje-y-programacion","title":"Montaje y programaci\u00f3n","text":"<ol> <li> <p>Montaje F\u00edsico: La ESP32 y el servo se ensamblaron en la protoboard. La l\u00ednea de se\u00f1al del servo se conect\u00f3 al GPIO 12 de la ESP32. Se aseguraron conexiones separadas de alimentaci\u00f3n (5V) y tierra (GND) para el servo.</p> </li> <li> <p>Desarrollo del C\u00f3digo: Se program\u00f3 la l\u00f3gica de control para establecer un ciclo secuencial de movimiento a 0\u00b0, 90\u00b0 y 180\u00b0. Se emple\u00f3 la funci\u00f3n map() para asegurar la correcta correspondencia entre los \u00e1ngulos y el ciclo de trabajo PWM.</p> </li> <li> <p>Verificaci\u00f3n: Se carg\u00f3 el programa a la ESP32 y se monitore\u00f3 el movimiento f\u00edsico del servo. Los retardos de 1000 ms se usaron para confirmar cada posici\u00f3n.</p> </li> </ol>"},{"location":"servos/#codigo-arduino","title":"C\u00f3digo Arduino","text":"<pre><code>/**\n * @file Control_Servo_Libreria.ino\n * @brief Control secuencial de un servomotor (0\u00b0, 90\u00b0, 180\u00b0) usando la librer\u00eda Servo.h en ESP32.\n * * La librer\u00eda Servo.h simplifica el control al encargarse de la gesti\u00f3n interna del PWM.\n */\n\n// Incluir la librer\u00eda Servo espec\u00edfica para ESP32\n// NOTA: Para ESP32, a menudo se usa \"ESP32Servo.h\" o simplemente \"Servo.h\"\n// Si Servo.h no funciona, intente usar ESP32Servo.h\n#include &lt;Servo.h&gt; \n\n// --- Configuraci\u00f3n de Pines y Objetos ---\n\n#define SERVO_PIN 12 // Pin GPIO donde se conecta la se\u00f1al del servo (Pin de ejemplo)\n\n// Crea un objeto Servo para controlar el motor\nServo miServo; \n\n// --- Setup (Configuraci\u00f3n Inicial) ---\nvoid setup() {\n    Serial.begin(115200);\n    Serial.println(\"Inicializando Servomotor con Servo.h...\");\n\n    // Asocia el objeto Servo al pin de salida\n    // Este paso configura autom\u00e1ticamente el canal PWM necesario en el ESP32\n    miServo.attach(SERVO_PIN); \n\n    // Asegurar que el servo inicie en una posici\u00f3n conocida\n    miServo.write(0); \n    delay(1000);\n}\n\n// --- Loop Principal (Ejecuci\u00f3n Continua) ---\nvoid loop() {\n    // Mover a 0 grados\n    Serial.println(\"Movimiento a 0 grados\");\n    miServo.write(0); \n    delay(1500); // Usamos un retardo ligeramente mayor para notar el movimiento\n\n    // Mover a 90 grados\n    Serial.println(\"Movimiento a 90 grados\");\n    miServo.write(90); \n    delay(1500);\n\n    // Mover a 180 grados\n    Serial.println(\"Movimiento a 180 grados\");\n    miServo.write(180); \n    delay(1500);\n}\n</code></pre>"},{"location":"servos/#resultados-y-conclusion","title":"Resultados y conclusion","text":"<p>Los resultados de la fase de pruebas confirmaron la viabilidad del m\u00e9todo de control implementado, demostrando una respuesta angular precisa e inmediata del servomotor al posicionarse exactamente en los puntos preestablecidos (0\u00b0, 90\u00b0, 180\u00b0), lo que verifica la integridad de la conexi\u00f3n f\u00edsica. La clave del \u00e9xito fue la funci\u00f3n map(), que result\u00f3 cr\u00edtica para la calibraci\u00f3n al permitir la traducci\u00f3n efectiva y lineal del rango l\u00f3gico (0-180) al ciclo de trabajo PWM (205-410) requerido. Adem\u00e1s, los datos num\u00e9ricos del ciclo de trabajo PWM comunicados por el monitor serial coincidieron rigurosamente con el movimiento f\u00edsico observado, validando la l\u00f3gica de programaci\u00f3n y la precisi\u00f3n del c\u00e1lculo matem\u00e1tico. Esta actividad consolid\u00f3 la comprensi\u00f3n pr\u00e1ctica del control de actuadores angulares mediante la t\u00e9cnica PWM en la plataforma ESP32 y reforz\u00f3 el entendimiento de la relaci\u00f3n cr\u00edtica entre la frecuencia del pulso, el ciclo de trabajo de la se\u00f1al PWM y el desplazamiento angular preciso que se obtiene en el servomotor.</p>"}]}